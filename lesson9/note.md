福特架构之前

**单指令-多线程** 

single instruction multiple threads.

指的就是同一个线程束中，各个分支的次序是顺序执行的

也就是说，如果这个线程束中的32个线程，他们的代码当然是一样的。

但是里面有一个if。

比如

```
__global__ void add(const double *x,const double*y,double *z)
{
    int index = threadIdx.x + blockDim.x+ blockIdx.x;
    
    if(index%2 == 0)
    {
        z[index] = x[index] + y[index];
    } else 
    {
        z[index] = x[index] - y[index];
    }
}
```

虽然明面上是32个线程并发执行，但是同时只能执行if中的某一个，比如这里32个线程中，16个index为even，16个index为odd。所以本质上是16个线程并行。

这种缺陷叫做**分支发散 branch divergence**

所以写代码时要避免分治发散。

但是实际上的逻辑中分治发散是不可避免的。因为逻辑就在那里。

一种好的解决策略是：**分支发散的另一个分支，不进行任何操作，这样对整体也没什么影响**



福特架构之后

每个线程有自己的寄存器了，这样会导致线程寄存器少一点



## 线程束内同步函数

回忆一下以前的线程块内同步函数，在重复读取同一块内存时，我们希望一个读取写入操作完成后，再对这块内存进行另一次读取。

为了实现这种目的，我们有两种思路。

1. 使用原子操作，一口气执行完避免同时读取
2. 使用线程同步机制

首先是线程块内的同步。因为我们都知道**线程块本质上是一个逻辑组织**，因为这个逻辑组织内本质上还是以线程束来执行的。逻辑的含金量就在可以share_memory中可以减少对global_memory的访问。

但是_syncthreads() 这个很慢，因为线程块是以warp放在SM中执行的。同一个线程块的线程必须在一个SM中。

也就是说一个block可以由多个wrap组成。但如果一个线程块刚好是32个线程，可以被一个warp完美运行。那么我们就可以用warp同步机制了。比如

__warpthreads() 这个函数

```
__warpthreads(unsigned mask = 0xffffffff);
```

这个参数是一个32位的二进制，每一个1表示这个warp内的对应线程参与同步。遮蔽线程块内同步要快很多。

因为哪怕线程块也是借助warp来并行执行的。



## 更多线程束内基本函数



### 束内指标

我们都知道，线程是按线程束执行的。标记一个线程，由blockIdx 和 threadIdx共同决定的。

同样的，对于一个线程来说，他在warp内也有独立的id。比如这个block有128个线程，

对于线程id位 34的线程，它位于第二个warp，束内ID为

```
int lane_id = threadIdx.x % wapr_size;
```

也可以更加推荐的按位与指标

```
int lane_id = threadIdx.x % (w_size-1); 
```

比如线程块大小16，手动设置的w为8

则有如下对应关系

```
线程指标 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  
束内指标 0  1  2  3  4  5  6  7  0  1   2   3   4   5   6   7
```

还有一个量叫做 MASK掩码。他是上面提到过的32位二进制，标明了这一个warp内的32的线程。

当对应的二进制为1时，表示参与了计算。



### 经典函数

#### 投票函数

__ballot_sync(mask, predicate)。

返回无符号整数，如果线程中的第n个线程参与运算，切predicate不为0，则返回的第n为二进制为1.

前面的mask表示参与投票（计算）的线程，和前面的MASK掩码一样。

相当于从一个mask获得了一个mask

__all_sync(mask,predicate);

返回值为0和1.

参与现成的predicate都不为0时才返回1

__any_sync(mask,predicate);

返回值0和1.

只要有一个不为0就返回1.



#### 线程束洗牌函数

说白了就是在线程束内交换某些数据。

T __shfl_sync(mask, v, srcLane, w)

mask中为1的参与线程，获得线程束内线程编号为srcLane的变量v的值.

理解为一种广播机制： 把某个线程的某个值，广播到线程束内的所有值。





T __shfl_up_sync (mask, v , d, w)

对于一个标号为t的线程，获得标号为t-d的线程中v的值。

对于t-d <0的线程获得自身的v。

比如当线程束大小为8时。设置d=2；

则2号线程获得 0号线程的v的值。

3号贤臣获得 1号线程的值。

0号线程和1号线程的值还是他本身。

实现了一种把某个数据向上运输的功能。

也可以理解为从0开始到 w-d-1为止，每个线程都把自己的v往上运d个单位。

不过这种理解不太适合获得某个值的思考方式。



T __shfl_down _ sync (mask, v, d, w)

标号为t的线程获得t+d线程的v的值，把数据从上往下拿，和up相反



T __shfl _ xor _ sync(mask, v , laneMask, w);

标号为t的线程获得 t异或laneMask的结果。比如我们取laneMask为2，w为8 二进制为 0010。

则束内坐标分别是0 1 2 3 4 5 6 7

异或后的结果分别是 2 3 0 1 6 7 4 5。

发现什么了吗？用xor交换，可以实现上面的三个交换！！奇妙desuwa









